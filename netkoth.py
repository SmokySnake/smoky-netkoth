#!/usr/local/bin/python
"""
This is Irongeek's automated scoring code for the NetKotH game.
Create a netkothconfig.ini in the same directory as the script
to look something like:
______________________________________________________________
[General]
outfile = default.htm
sleeptime = 6

[Servers To Check]
linux = http://127.0.0.1/a.htm
windows = http://127.0.0.1/b.htm
wildcard = http://127.0.0.1/c.htm
______________________________________________________________
Server names can be changed (no ":" or "=" characters please),
and the score file will be generated by the script. I'm just now
learning Python, so I'm sure there are better ways to do some
of the tasks I do in this script. You can also make a
template.htm file, and tags that match the server name in all
upper case will be replaced with the score information for that
box.

"""
import urllib2
import urllib
import re
import ConfigParser
import time
import re
import random

#------Make some globals
config = ConfigParser.RawConfigParser()
scores = ConfigParser.RawConfigParser()
configfile =""
serverstoignore = ""
serverstocheck = ""
sleeptime = ""
outfile = ""
PORT = 8000

# True flag changes the port that flags are read from, every 15 flag grabs
RANDOM_PORT = True
flag_port = 80
DHCP_FLAGS = ""

# flagdetails = [personalFlag][currentOwner]
flagdetails=[[],[]]


def getsettings(while_counter):        
        print "Grabbing settings"
        global configfile, serverstocheck, sleeptime, outfile, serverstoignore, DHCP_FLAGS

        # Get the dhcp flags setting
        configfile = config.read("baseconfig.ini")
        DHCP_FLAGS = config.get("General", "dhcp")
        if DHCP_FLAGS:
            get_ips(while_counter)
        else:
            # If no DHCP_FLAGS set, then need to write to netkothconfig.ini like get_ips does
            base_file = open('baseconfig.ini', 'r')
            out_string = base_file.read()
            out_file = open('netkothconfig.ini','w')
            # Write the output string to the config file
            n = out_file.write(out_string)

            # Clean up and close out of opened files
            out_file.close()
            base_file.close()
            
        # Get remaining settings
        configfile = config.read("netkothconfig.ini")
        serverstoignore = config.items("Servers To Ignore")
        serverstocheck = config.items("Servers To Check")
        sleeptime = config.getint("General", "sleeptime")
        outfile = config.get("General", "outfile")


# Remove the serverstoignore from serverstocheck list
def removeservers():
        global serverstocheck, serverstoignore
        remove_server = []
        for server in serverstocheck:
            remove_flag = False
            for ignoreserver in serverstoignore:
                if ignoreserver[1] in server[1]:
                    remove_flag = True
            if remove_flag == True:
                remove_server.append(1)
            else:
                remove_server.append(0)

        server_counter = 0
        for this_server in remove_server:
            if this_server == 1:
                del serverstocheck[server_counter]
            else:
                server_counter += 1

def checkpagesandscore():
        global flagdetails 
        scoresfile = scores.read("netkothscores.txt")
        flagdetails = [[],[]]
        for server in serverstocheck:
            try:
                print "About to check server " + server[0] + " " + server[1]
                url = urllib2.urlopen(server[1],None,10)
                #url = urllib2.urlopen(server[1])
                html = url.read()        
                team = re.search('<team>(.*)</team>', html, re.IGNORECASE).group(1).strip().replace("=","").replace("<","").replace(">","")
                flagdetails[1].append(team)
                print "Server " + server[0] + " owned by " + team
                serverscoressection = server[0]+"Scores"
                if not scores.has_option("TotalScores", team): 
                    scores.set("TotalScores", team, 0)
                currentscore = scores.getint( "TotalScores",team)
                scores.set( "TotalScores", team, currentscore+1)
                if not scores.has_option(serverscoressection, team): 
                    scores.set(serverscoressection, team, 0)
                currentscore = scores.getint( serverscoressection,team)
                scores.set( serverscoressection, team, currentscore+1)
                if re.search('<personal>.*</personal>', html):
                    personal = re.search('<personal>(.*)</personal>', html, re.IGNORECASE).group(1).strip().replace("=","").replace("<","").replace(">","")
                    print "Server is " + personal + "'s personal host. Do not hack!!"
                    flagdetails[0].append(1)
                else:
                    flagdetails[0].append(0)
            except IOError:
                print server[0] + " " + server[1] + " may be down, skipping it"
                flagdetails[0].append(0)
                flagdetails[1].append("")
            except AttributeError:
                print server[0] + " may not be owned yet"
                flagdetails[0].append(0)
                flagdetails[1].append("")
        with open("netkothscores.txt", 'wb') as scoresfile:                
                scores.write(scoresfile)

def makescoresections():
        scoresfile = scores.read("netkothscores.txt")
        if not scores.has_section("TotalScores"):
                scores.add_section("TotalScores")

        for server in serverstocheck:
                serverscoressection = server[0]+"Scores"
                if not scores.has_section(serverscoressection):
                        scores.add_section(serverscoressection)
        
# Creates individual flag tables (including Total). 
# SmokySnake updated to check for personal tag and note, plus highlight current flag owner
# not just the highest scorer
def maketables(server, server_count):
        global flagdetails
        print "Making score table for " + server[0]
        try:
            serverscoressection = server[0]+"Scores"
            serverscores = scores.items(serverscoressection)
            tableresults = "<div id=\"" + server[0] + "\">"
            tableresults = tableresults + "<table border=\"2\">\n<tr>"

            # If flag has personal tag, or is the Total table, create normal table
            # else note as a personally tagged flag with "*Pers"
            if not flagdetails[0][server_count] or "Total" in server[0]:
                tableresults = tableresults + "<td colspan=\"2\"><center><b class=\"scoretabletitle\">" +(server[0]).title() + "</b><br>"
            else:
                tableresults = tableresults + "<td colspan=\"2\"><center><b class=\"scoretabletitle\">" +(server[0]).title() + "*Pers</b><br>"
            tableresults = tableresults + "<a href=\"" + server[1] + "\">" + server[1]  +"</a>"
            tableresults = tableresults + "</center></td>"
            tableresults = tableresults + "</tr>\n"
            serverscores.sort(key=lambda score: -int(score[1]))
            toptagstart="<div class=\"topscore\">"
            othertagstart="<div class=\"otherscore\">"
            toptagend="</div>"
            othertagend="</div>"
            # For the Total table, highlight top scorer
            if "Total" in server[0]:
                temp_team_count = 0
                for team in serverscores:
                    if temp_team_count == 0:
                        tableresults = tableresults + "<tr><td>" + toptagstart + team[0].title() + toptagend + "</td><td>" + toptagstart + str(team[1]) +  toptagend  + "</td></tr>\n"
                    else:
                        tableresults = tableresults + "<tr><td>" + othertagstart + team[0].title() + othertagend + "</td><td>" + othertagstart + str(team[1]) +  othertagend  + "</td></tr>\n"
                    temp_team_count += 1
                tableresults = tableresults + "</table></div>"
            # For all other flag tables, highlight current flag owner
            else:
                for team in serverscores:
                    if team[0] == flagdetails[1][server_count]:
                        tableresults = tableresults + "<tr><td>" + toptagstart + team[0].title() + toptagend + "</td><td>" + toptagstart + str(team[1]) +  toptagend  + "</td></tr>\n"
                    else:
                        tableresults = tableresults + "<tr><td>" + othertagstart + team[0].title() + othertagend + "</td><td>" + othertagstart + str(team[1]) +  othertagend  + "</td></tr>\n"
                tableresults = tableresults + "</table></div>"
            return tableresults
        except Exception:
            print "No section for " + server[0]

# Writes all DHCP leases in the dhcpd.leases file to the config file to collect flags from
# This currently means expired IPs as well as participants IPs are set up as flags at
# http://IP:80/flag.html. Adds interesting dynamic but might need to change.
# TODO: Change the port that flags are found at. Forces participants to listen to net traffic
def get_ips(while_counter):
    global flag_port, RANDOM_PORT
    # The file where dhcp files are kept (including old ones)
    lease_file = open('/var/lib/dhcp/dhcpd.leases', 'r')

    # The user modifiable configuration file, used as the base for the active config file
    base_file = open('baseconfig.ini', 'r')
    out_string = base_file.read()

    # The file final flag ips are written to
    out_file = open('netkothconfig.ini','w')

    # Match on all IPs
    ip_pattern = re.compile("\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}")

    # Extract unique IPs from file since sets don't write duplicates (including expired IPs)
    ips = list(set(result.lower() for result in re.findall(ip_pattern, lease_file.read(), flags=0)))
    ips.sort()

    # Prepare the output
    var_num = 1

    # If flag port randomisation is set, change flag port between 7990-8010 every 15 flag grab cycles (mins)
    if RANDOM_PORT == True and while_counter % 15 == 0:
        flag_port = 8000 + random.randint(-10,10)
    for ip in ips:
        out_string += 'flag' + str(var_num) + ' = ' + 'http://' + ip + ":" + str(flag_port) + '/flag.html\n'
        var_num += 1

    # Write the output string to the config file
    n = out_file.write(out_string)

    # Clean up and close out of opened files
    out_file.close()
    base_file.close()
    lease_file.close()

#------Main begin
while_counter = 1
while 1:
        #------Check files that may have changed since las loop
        getsettings(while_counter) #-------Grab core config values, you have the option to edit config file as the game runs
        #------Update config file IPs from DHCP leases
        get_ips(while_counter)
        removeservers()
        makescoresections() #In case score setions for a bax are not there
        templatefilehandle = open("template.htm", 'r')        
        scorepagestring=templatefilehandle.read()
        #------Look at all the pages to see who owns them.
        checkpagesandscore()       

        #------Make Tables
        server_count = 0
        for server in serverstocheck:
            thistable = maketables(server, server_count)
            serverlabeltag=("<" + server[0] + ">").upper()
            server_count += 1
            print "Searching for " + serverlabeltag + " tag to replace in template.htm (case sensitive)"
            scorepagestring = scorepagestring.replace(serverlabeltag,thistable)
        #------Make Total Table
        thistable = maketables(["Total",""],0)
        serverlabeltag=("<TOTAL>").upper()
        print "Searching for " + serverlabeltag + " to replace (case sensitive)"
        scorepagestring = scorepagestring.replace(serverlabeltag,thistable)
        #------Making the score page
        print "Writing " + outfile
        outfilehandle = open(outfile, 'w')
        outfilehandle.write(scorepagestring)
        outfilehandle.close()
        print "Sleeping for " + str(sleeptime)
        while_counter += 1
        time.sleep(sleeptime)
#------Main end
